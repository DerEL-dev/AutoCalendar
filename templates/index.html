<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AutoCalendar</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
    #addForm {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
    }
    #addForm input {
      margin: 2px;
    }
    #addForm button {
      margin-top: 5px;
    }
  </style>
</head>
<body>

<canvas id="canvas"></canvas>

<!-- Einfaches Formular um Termine hinzuzufÃ¼gen -->
<div id="addForm">
  <div>
    Tag (0=Mo,6=So): <input type="number" id="day" min="0" max="6" value="0">
  </div>
  <div>
    Startzeit (z.B. 9.5=09:30): <input type="number" id="start" step="0.25" value="9.5">
  </div>
  <div>
    Endzeit: <input type="number" id="end" step="0.25" value="10.5">
  </div>
  <div>
    Titel: <input type="text" id="title" value="Meeting">
  </div>
  <button onclick="submitAppointment()">Termin hinzufÃ¼gen</button>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// Kamera
let camX = 0;
let camY = 0;
let zoom = 1;

// Gitter
const spacing = 50;
const dotRadius = 2;

// Input
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

// Maus
let dragging = false;
let lastX = 0;
let lastY = 0;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

window.addEventListener("mousemove", e => {
  if (!dragging) return;
  camX -= (e.clientX - lastX) / zoom;
  camY -= (e.clientY - lastY) / zoom;
  lastX = e.clientX;
  lastY = e.clientY;
});

// Zoom
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const factor = 1.1;
  zoom *= e.deltaY < 0 ? factor : 1 / factor;
  zoom = Math.min(Math.max(zoom, 0.2), 5);
}, { passive: false });

// Termine
let appointments = [];

// Funktion: Termin hinzufÃ¼gen Ã¼ber API
function submitAppointment() {
  const day = parseInt(document.getElementById("day").value);
  const start = parseFloat(document.getElementById("start").value);
  const end = parseFloat(document.getElementById("end").value);
  const title = document.getElementById("title").value;

  fetch("/api/appointments", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({day, start, end, title})
  })
  .then(res => res.json())
  .then(() => fetchAppointments()); // Nach dem HinzufÃ¼gen aktualisieren
}

// Termine vom Backend abrufen
function fetchAppointments() {
  fetch("/api/appointments")
    .then(res => res.json())
    .then(data => appointments = data);
}

// Box-Funktion
function drawRoundedBox(x, y, w, h, text) {
  const r = 12;
  ctx.fillStyle = "#1e1e1e";
  ctx.strokeStyle = "#4aa3ff";
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();

  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = "#fff";
  ctx.font = "16px sans-serif";
  ctx.fillText(text, x + 10, y + 24);
}

// Update
function update() {
  const speed = 12 / zoom;
  if (keys["ArrowLeft"])  camX -= speed;
  if (keys["ArrowRight"]) camX += speed;
  if (keys["ArrowUp"])    camY -= speed;
  if (keys["ArrowDown"])  camY += speed;
}

// Render
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(zoom, zoom);
  ctx.translate(-camX, -camY);

  // ðŸ”¥ Endloses Gitter
  const startX = Math.floor((camX - canvas.width / zoom) / spacing) * spacing;
  const endX   = Math.floor((camX + canvas.width / zoom) / spacing) * spacing;
  const startY = Math.floor((camY - canvas.height / zoom) / spacing) * spacing;
  const endY   = Math.floor((camY + canvas.height / zoom) / spacing) * spacing;

  ctx.fillStyle = "#aaa";
  for (let x = startX; x <= endX; x += spacing) {
    for (let y = startY; y <= endY; y += spacing) {
      ctx.beginPath();
      ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Wochentage
  let weekdays = ["Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag"];
  for (let x = 0; x < 70; x++) {
    drawRoundedBox(
      x*200,
      0,
      200,
      50,
      weekdays[x%7]
    );
  }

  // Uhrzeiten
  for (let y = 0; y < 4*24; y++) {
    drawRoundedBox(
      -100,
      y*50+50,
      100,
      50,
      String(Math.floor(y/4)) + ":" + ["00","15","30","45"][y%4]
    );
  }

  // Termine zeichnen
  appointments.forEach(a => {
    const x = a.day * 200 + 10;
    const y = a.time * 200 + 50;
    drawRoundedBox(
      x,
      y,
      180,
      45,
      a.title
    );
  });

  ctx.restore();
}

// Loop
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

// Beim Start Termine laden
fetchAppointments();

</script>
</body>
</html>
